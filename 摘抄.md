4、模块与函数
 - Erlang shell内建命令：
    pwd().
    ls().
    cd(Dir).
 - fun 匿名函数
    Double = fun(X) -> 2*X end.   Double(4).
    Hypot = fun(X, Y) -> math:sqrt(X*X+Y*Y) end.
    TempConvert = fun({c, C}) -> {f, 32+C*9/5};
                     ({f, F}) -> {c, (F-32)*5/9}
                    end.
 - 以 fun 为参数的函数:lists:map(F, L)
    F = fun(X) -> 2*X end.
    L = [1,2,3,4].
    lists:map(F, L).
        [2,4,6,8].
 - 以 fun 为参数的函数:lists:filter(P, L)
    Even = fun(X) -> (X rem 2) =:= 0 end.
    lists:filter(Even, [1,2,3,4]).
 - 返回 fun 的函数:
    Fruit = [apple, pear, orange].
    MakeTest = fun(L) -> (fun(X) -> lists:member(X, L) end) end.
    IsFruit = MakeTest(Fruit).
    IsFruit(apple).
    同样，还能将其用作lists:filter/2的参数：
    lists:filter(IsFruit, [dog, orange, cat]).
 - for 循环
    for(Max, Max, F) -> [F(Max)];
    for(Min, Max, F) -> [F(Min) | for(Min+1, Max, F)].
 - lib_misc:for(1,5,fun(I) -> I end).
 - lib_misc:for(1,5,fun(I) -> I*I end).
 - 列表解析
    lists:map(fun(X) -> 2*X end, L).
    [2*X || x <- L].
    列表解析中的生成器也可以像过滤器一样：
        [X || {a,X} <- [{a,1}, {b,2}, hello, "wow"].
    快速排序：
        qsort([]) -> [];
        qsort([Pivot|T]) ->
            qsort([X || X <- T, X < Pivot])
            ++ [Pivot] ++
            qsort([X || X <- T, X >= Pivot]).
    毕达哥拉斯三元组：
        pythag(N) ->
            [{A,B,C} ||
            A <- lists:seq(1,N),
            B <- lists:seq(1,N),
            C <- lists:seq(1,N),
            A+B+C =< N,
            A*A+B*B =:= C*C].
    变位词：
    perms([]) -> [[]];
    perms(L) -> [[H|T] || H <- L, T <- perms(L--[H])].
    lib_misc:perms("123").
    X--Y 是列表的分离操作符，从列表X中分离出元素Y
 - 算术表达式
    bnot X 对X按位取反
    X div Y X整除Y
    X rem Y X除Y取余数
    X bor Y 对X和Y按位取或
    X bxor Y 对X和Y按位进行异或
    X bsl N 对X按位左移N位
    X bsr N 对X按位右移N位
 - 断言：
    断言是一种用于强化模式匹配功能的结构。
    使用断言，可以在一个模式上做一些简单的变量测试和比较
    max(X, Y) when X > Y -> X;
    max(X, Y) -> Y.
    断言集合以逗号分开时，所有断言都为true，整个断言序列才为true。
    断言集合以分号分开时，只要任何一个断言为true，整个断言就为true。
    断言谓语：
        is_atom(X)
        is_binary(X)
        is_constant(X)
        is_integer(X)
        is_list(X)
        is_number(X)
        is_function(X)
        is_float(X)
        is_function(X, N)
        is_pid(X)
        is_port(X)
        is_reference(X)
        is_tuple(X)
        is_record(X, Tag)
        is_record(X, Tag, N)
    断言BIF(build in function):
        abs(X)
        element(N, X) 元组X的第N个元素
        float(X)
        hd(X) 列表X的头部
        length(X)
        node() 当前节点
        node(X) 创建X的节点，X可以是进程标识符、引用或端口
        round(X) 将数字X转换为整数（四舍五入）
        self() 当前进程的进程标识符
        size(X) X的大小，X为元组或二进制数据
        trunc(X) 将数字X转换为整数（截取）
        tl(X) 列表X的尾部
    短路布尔表达式的断言:
        andalso orelse
 - 记录
    -record(Name, {
                key1 = Default1,
                key2 = Default2,
                ...
                key3,
                ...
                }).
    记录可以存入Erlang源代码或以.hrl为扩展名的文件中，这些文件可以被Erlang源代码引用
    records.hrl:
    -record(todo, {status=reminder, who=joe,text}).
    shell中读取记录的命令：
    rr("records.hrl").
    创建和更新记录：
        X = #todo{}.
        X1 = #todo{status=urgent, text="Fix errata in book"}.
        X2 = X1#todo{status=done}.
        #todo{who=W, text=Txt} = X2.
        X2#todo.text.
    对一个记录的字段进行模式匹配并创建一个新的记录：
        clear_status(#todo{status=S, who=W} = R) ->
            R#todo{status=finished}
    匹配一个特定类型的记录：
        do_something(X) when is_record(X, todo) ->
            %% ...
    记录就是元组
    shell释放掉记录todo的定义：rf(todo).
 - case表达式：
    filter(P, [H|T]) ->
        case p(H) of
            true -> [H|filter(P, T)];
            false -> filter(P, T)
        end;
    filter(P, []) ->
        [].
 - if表达式：
    if
        Guard1 ->
            Expr_seq1;
        Guard2 ->
            Expr_seq2;
        ...
    end
 - lists:reverse/1 高度优化
 - List ++ [H] 极为低效
 
        
                
        
    
    
    
    
    