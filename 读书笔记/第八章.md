8、Erlang顺序编程补遗
 - apply:
    它与直接调用函数的区别在于模块名和函数名可以是动态计算得出的。
 - compile(Options).
    添加Options到编译器选项列表中，Options可以是单个编译器选项，也可以是一个编译器选项列表。
    compile(export_all)，这个编译器选项经常会在调试程序时用到，它会导出模块里所有的函数，无需再显式使用-export标识。
 - vsn(Version)
    指定模块的版本号。Version可以是任何字面数据类型。
 - attrs:module_info().
    提取模块属性的值。
    attrs:module_info(X). 返回与模块相关的单个属性。
    要运行attrs:module_info()必须先把attrs模块的beam代码加载到Erlang虚拟机里。
    beam_lib:chunks("attrs.beam", [attributes]). 可以在不载入模块代码的情况下提取模块里的属性数据。
 - 块表达式：
    begin
        Expr1,
        ...
        ExprN
    end
 - 字符集：
    从R16B开始，Erlang源码文件都假定采用UTF-8字符集编码。
    在这之前，采用ISO-8859-1(Latin-1)字符集。
    Erlang内部没有字符串数据类型，字符串其实不存在，而是由整数数列来表示。
 - 注释：
    从一个百分号（%）开始
    Erlang没有块注释
 - 动态代码载入
    在任何一时刻，Erlang允许一个模块的两个版本同时运行：当前版本和旧版本。
    重新编译某个模块时，任何运行旧版代码的进程都会被终止，当前版成为旧版，新编译的版本则成为当前版本。
 - Erlang的预处理器：
    Erlang模块在编译前会自动