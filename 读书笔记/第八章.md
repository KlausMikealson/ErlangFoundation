8、Erlang顺序编程补遗
 - apply:
    它与直接调用函数的区别在于模块名和函数名可以是动态计算得出的。
 - compile(Options).
    添加Options到编译器选项列表中，Options可以是单个编译器选项，也可以是一个编译器选项列表。
    compile(export_all)，这个编译器选项经常会在调试程序时用到，它会导出模块里所有的函数，无需再显式使用-export标识。
 - vsn(Version)
    指定模块的版本号。Version可以是任何字面数据类型。
 - attrs:module_info().
    提取模块属性的值。
    attrs:module_info(X). 返回与模块相关的单个属性。
    要运行attrs:module_info()必须先把attrs模块的beam代码加载到Erlang虚拟机里。
    beam_lib:chunks("attrs.beam", [attributes]). 可以在不载入模块代码的情况下提取模块里的属性数据。
 - 块表达式：
    begin
        Expr1,
        ...
        ExprN
    end
 - 字符集：
    从R16B开始，Erlang源码文件都假定采用UTF-8字符集编码。
    在这之前，采用ISO-8859-1(Latin-1)字符集。
    Erlang内部没有字符串数据类型，字符串其实不存在，而是由整数数列来表示。
 - 注释：
    从一个百分号（%）开始
    Erlang没有块注释
 - 动态代码载入
    在任何一时刻，Erlang允许一个模块的两个版本同时运行：当前版本和旧版本。
    重新编译某个模块时，任何运行旧版代码的进程都会被终止，当前版成为旧版，新编译的版本则成为当前版本。
 - Erlang的预处理器：
    Erlang模块在编译前会自动由Erlang的预处理器进行处理。
    预处理器会展开源文件里所有的宏，并插入必要的包含文件。
    查看预处理器的输出：
        erlc -P some_module.erl
        会生成名为some_module.P的清单文件
 - 数字
    表示整数的位数只受限于可用的内存。
    除10以外的数字进制整数使用K#Digits这种写法。
    最高进制是36。
    浮点数 = 一个可选正负号 + 一个整数部分 + 一个小数点 + 一个分数部分 + 一个可选的指数部分。
    解析后的浮点数在系统内部使用IEEE_754的64位格式表示。
    绝对值在10^(-323)到10^(308)内的实数可以用Erlang的浮点数表示。
 - 操作符优先级
    - ++、--、-!右结合
 - 进程字典
    - get_keys(Value) -> [Key].
        返回一个列表，内含字典里所有值为Value的键。
    - erase(Key) -> Value.
        返回Key的关键值，如果不存在则返回原子undefined。最后删除Key的关联值。
    - erase() -> [{Key, Value}]
        删除整个进程字典。
 - 引用
    引用是一种全局唯一的Erlang数据类型。
    它们由内置函数erlang:make_ref()创建。
    引用的用途是创建独一无二的标签，把它存放在数据里并在后面用于比较是否相等。
 - 比较数据类型
    == 只有在比较浮点数和整数时才有用。
     