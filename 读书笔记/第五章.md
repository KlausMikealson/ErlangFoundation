5、记录与映射组
 - 元组用于保存固定数量的元素，列表用于保存可变数量的元素
 - 记录使用一组固定且预定义的名称，映射组可以动态添加新的名称
 - 映射组比元组占用更多存储空间，查找起来也更慢，映射组比元组灵活
 - 文件包含是唯一能确保多个Erlang模块共享相同记录定义的方式
 - 选择记录的情况：
    - 可以用一些预先确定且数量固定的原子表示数据
    - 记录里的元素数量和元素名称不会随时间而改变
    - 存储空间是个问题
 - 选择映射组的情况：
    - 当键不能预先知道时
    - 当存在大量不同的键时
    - 当方便使用很重要而效率无关紧要时
    - 用作“自解释型”的数据结构，也就是说，用户容易从键名猜出值的含义
    - 用来表示键值解析树，例如XML或配置文件
    - 用JSON来和其他编程语言通信
 - shell里使用记录：
    - rr("xx.hrl")
    - rf(todo)
 - 映射组：关联式键值存储
    - 与记录相似，不同之处，省略了记录名，并且键值分隔符是=>或：=
    - 映射组里的键可以是任何全绑定的Erlang数据类型（即数据结构里没有任何未绑定的变量）
    - 各个元素根据键进行排序
    - 在不改变键的情况下更新映射组是一种节省空间的操作
    - 查询映射组的某个键的值是一种高效操作
    - 有明确的顺序
    - K => V 有两种用途：
        - 将现有键K的值更新为新值V
        - 给映射组添加一个全新的K-V
    - K := V :
        - 将现有键K的值更新为新值V
        - 如果被更新的映射组不包含键K，这个操作会失败
    - 统计各个字符出现的次数：
        count([H|T], #{H => N} = X) ->
            count(T, X#{H := N+1});
        count([H|T], X) ->
            count(T, X{H => 1});
        count([], X) ->
            X.
 - 操作映射组的内置函数
    - maps:new() ->#{}
    - erlang:is_map(M) -> bool()
    - maps:to_list(M) -> [{K1, V1},...,{Kn, Vn}] （键在生成的列表中严格按升序排列）
    - maps:map_size(M) -> NumberOfEntries
    - maps:is_key(Key, M) -> bool()
    - maps:get(Key, M) -> Val|抛出异常
    - maps:find(Key, M) -> {ok, Val}|error
    - maps:keys(M) -> [K1, K2...]
    - maps:remove(K, M) -> M1
    - maps:without([K1, K2...], M) -> M1
    - maps:difference(M1, M2) -> M3 (M3是M1的复制，但移除了那些与M2里元素具有相同键的元素)
 - 映射组在比较时首先会比较大小，然后按照键的排序比较键和值
 - 映射组与JSON
    - maps:to_json(M) -> Bin
        (并不是所有的映射组都能转换成JSON，映射组里所有的值都必须是能用JSON表示的对象，例如不能包含：fun，进程标识符，引用)
    - maps:from_json(Bin) -> Map
 - JSON对象与Erlang值的映射关系：
    JSON            Erlang
    数字            整数或浮点数
    字符串          二进制型
    列表            列表
    true|false      true|false
    对象            映射组